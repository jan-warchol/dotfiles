# Note that old versions of git may not load configuration from ~/.config/git/config,
# loading only ~/.gitconfig.  Using git >= 2.0 is _strongly_ recommended!

[alias]
    # SIMPLE "SHORTCUT" ALIASES

    # It can be convenient to view git output using `less`, but by default git
    # turns coloring off when the output is not a tty.  To override that we add
    # --color=always to some aliases (and use `less -R` for viewing).

    a = add
    aa = add --all
    ap = add --patch   # interactively select hunks to add, very useful
    au = add --update   # stage all changes in already tracked files

    b = branch
    bv = branch --verbose --verbose   # lists branches with SHAs and upstreams
    ba = branch --all
    br = branch --remotes
    bd = branch --delete
    BD = branch -D

    c = checkout
    c0 = checkout HEAD~0   # detach HEAD e.g. for throw-away experiments
    c1 = checkout HEAD~1
    c2 = checkout HEAD~2
    cb = checkout -b
    cm = checkout master
    com = checkout origin/master
    cu = checkout @{upstream}

    chp = cherry-pick

    # commit --verbose shows a preview of staged changes when editing the commit
    # message - you no longer have to run 'git diff' before every commit :)
    k = commit --verbose   # no git command starts with 'k', and 'k' matches pronunciation!
    ka = commit --verbose --all
    km = commit -m
    kma = commit --all -m   # 'kma' instead of 'kam' because it's easier to type
                            # and won't get confused with amending
    amn = commit --amend
    ama = commit --amend --all
    amq = commit --amend --all --no-edit

    d = diff --color=always --find-copies-harder --inter-hunk-context=13
    dc = !git d --cached   # preview changes staged for commit
    ds = !git d --stat   # force coloring for use with less -R
    dm = !git d master
    du = !git d @{upstream}
    dsm = !git ds master
    dsu = !git ds @{upstream}
    wd = !git d --word-diff=color   # mnemonic: Word-Diff
    wdc = !git d --word-diff=color --cached

    d5 = !git d --unified=5
    d8 = !git d --unified=8
    d13 = !git d --unified=13

    f = fetch --prune
    fa = fetch --all --prune

    # I tried do define 'g2', 'g3' etc. using 'g' alias to reduce duplication
    # (like this: g2 = !git g --context 2), but it turns out that when I use
    # '!git' construct, the command will always be ran from the repository root
    # (which in case of grep changes the behaviour, as it searches only inside
    # path from which it's ran).
    g = grep --color=always --line-number
    g2 = grep --color=always --line-number --context 2
    g3 = grep --color=always --line-number --context 3
    g5 = grep --color=always --line-number --context 5
    g8 = grep --color=always --line-number --context 8
    # when I want to see more context, I don't want filenames obscuring my
    # view.  This also makes it possible to copy-and-paste code snippets.
    gh = grep --color=always --heading
    gh5 = grep --color=always --heading --context 5
    gh8 = grep --color=always --heading --context 8
    gh13 = grep --color=always --heading --context 13
    gh21 = grep --color=always --heading --context 21
    # matches pattern only at word boundaries
    gw = grep --color=always --line-number --word-regexp
    ghw = grep --color=always --heading --word-regexp --context 8

    # search whole repository, not only current directory.
    # (in `!...` construct, commands are executed from repository root dir)
    gg = !git g
    gg3 = !git g3
    gg5 = !git g5
    gg8 = !git g8

    # always run log with --graph so that the topology will be visualized!
    l = log --color=always --decorate --graph
    lp = log --color=always --decorate --patch
    lpw = log --color=always --decorate --patch --word-diff=color

    ff = merge --ff-only
    noff = merge --no-ff

    # unlike plain `pull`, this won't attempt a merge that may result in conflicts
    pl = pull --ff-only

    pu = push
    puf = push --force-with-lease
    # push to a new branch with the same name
    psu = !git push --set-upstream $(git symbolic-ref --short HEAD)
    psuo = !git push --set-upstream origin $(git symbolic-ref --short HEAD)
    # tags have to be pushed explicitly
    put = !git push && git push --tags

    rba = rebase --abort
    rb = rebase
    rbc = rebase --continue
    rbo = rebase --onto   # quite useful, see examples in 'git help rebase'
    rbi = rebase --interactive
    rbi5 = rebase --interactive HEAD~5
    rbim = rebase --interactive master
    rbiu = rebase --interactive @{upstream}
    rbm = rebase master
    rbom = rebase origin/master

    rt = remote --verbose

    rs = reset
    rs1 = reset HEAD~1   # "soft undo" - remove last commit, but keep its changes
    rsu = reset @{upstream}

    sh = stash
    shp = stash pop

    s = status --short   # see also --branch option
    st = status
    su = status --short --untracked-files=all
    si = status --short --ignored
    sa = status --short --untracked-files=all --ignored

    who = shortlog --summary --numbered



    # PRETTY LOGS

    # Names are mnemonics based on common aliases of 'ls' command.
    # Inspired by http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs

    # basic one-line log, I use it all the time
    ls = !git log --color=always --decorate --graph --date=relative \
    --format=tformat:'%C(auto)%h%C(reset) -%C(auto)%d%C(reset) %s %C(dim)- %an, %ad%C(reset)'

    # as above, but includes all local and remote branches
    la = !git ls HEAD --branches --remotes

    lm = !git ls HEAD master

    # "Long" format - full commit message and summary of changes
    ll = !git log --color=always --decorate --graph --stat-graph-width=30 --stat-count=30

    lmpr = log --color=always --decorate --reverse --patch master..HEAD

    # similar to ls, but always include both HEAD and its upstream (if present)
    lu = !git ls HEAD `git for-each-ref --format='%(upstream:short)' HEAD $(git symbolic-ref --quiet HEAD)`

    # two-line version, useful when your terminal window is narrow
    l2 = !git log --color=always --decorate --graph --date=iso \
    --format=tformat:'%C(auto)%h%C(reset) %C(blue)%an%C(reset)%C(dim), %<(21,trunc)%ad%x08%x08%C(reset)%C(auto)%d%C(reset)%n        %s'

    # and a two-line log showing all branches
    l2a = !"git l2 HEAD --branches --remotes"

    # reflog with dates and commit message subject
    rf = log --walk-reflogs --format='%C(bold cyan)%gd%C(reset) %<(21,trunc)%ci%x08%x08 %C(auto)%h%C(reset) %gs %C(dim)- %<(33,trunc)%s%C(reset)'

    # log commits that differ between head and its upstream
    div = !GIT_PAGER='less -REXS' git ls --boundary HEAD...@{upstream}
    # log unpushed/unmerged commits on all branches
    unp = !GIT_PAGER='less -REXS' git ls --boundary --date-order --branches --not --remotes
    unm = !GIT_PAGER='less -REXS' git ls --boundary --date-order --remotes --not --branches

    # GUI versions of the above (simply runs gitk)
    divk = !gitk HEAD...@{upstream}
    unpk = !gitk --branches --not --remotes
    unmk = !gitk --remotes --not --branches



    # MORE SOPHISTICATED COMMANDS

    # "smart amend"
    #
    # Fixup a specified commit and use rebase to merge the fixup (like commit --amend,
    # but for commits before the currently checked-out one - see the description of
    # --fixup option in `git commit` manpage).  By default the fixup will incorporate
    # staged changes, but you can also use `-a` option (or specify paths), like with
    # `git commit` itself.
    # Don't use this if there was a merge after the commit to be amended.
    #
    fix = "!sh -c 'set -e; \
        commit_id=$(git rev-parse $1); \
        shift; \
        git commit --fixup $commit_id $@; \
        if ! git diff --quiet HEAD; then \
            dirtytree=1; \
            echo \"Stashing your other changes...\"; \
            git stash save \"Stashed before amending $commit_id\"; \
        fi; \
        git rebase --interactive --autosquash $commit_id~; \
        if [ -n \"$dirtytree\" ]; then \
            git stash pop; \
        fi' -"

    fixa = "!sh -c 'git fix $@ --all' -"
    fix1 = "!sh -c 'git fix @~1 --all' -"
    fix2 = "!sh -c 'git fix @~2 --all' -"

    # trash - discard changes
    #
    # Use this command instead of `reset --hard`, as it makes it possible to undo
    # the trashing.  Right now this is implemented simply by using `stash` command,
    # so to bring back discarded changes you just do `git stash pop <stash>`.
    #
    # Useful options:
    #     -p    select which hunks to discard
    #     -u    also remove untracked files
    #     -a    also remove untracked and ignored files
    #
    # TODO:
    # - add support for trashing changes in indvidual files
    # - rewrite this as a standalone git command
    # - send a patch upstream?
    #
    trash = !sh -c 'git stash save "$@" "changes trashed on $(date +\"%Y-%m-%d %H:%M\")"' -

    # temporarily ignoring files, see
    # http://gitready.com/intermediate/2009/02/18/temporarily-ignoring-files.html
    ignore = update-index --assume-unchanged
    unignore = update-index --no-assume-unchanged
    ignored = !git ls-files -v | grep "^[a-z]"

    # gethub X Y Z - fetch branch Z from repo Y of github user X
    gethub = !sh -c 'git fetch https://github.com/$1/$2 $3 && \
        git checkout FETCH_HEAD && \
        git checkout -b "$1/$2/$3"' -

    # "merge-base diff"
    mbd = !git diff `git merge-base HEAD $1`

    # search and replace in all tracked files except
    # - submodule entries (to avoid errors)
    # - symbolic links (to avoid transforming them to ordinary files)
    # usage: git sed 's/foo/bar/'
    sed = !git ls-files --stage | grep -v "^160000" | grep -v "^120000" | cut -f2 | xargs sed -i -e

    # delete current branch
    bdc = !sh -c 'BRANCH=$(git rev-parse --abbrev-ref HEAD) \
        && git checkout master \
        && git branch --delete $BRANCH'



[color]
    ui = auto

[color "branch"]
    remote = blue

[color "status"]
    changed = yellow
    untracked = cyan

[color "grep"]
    filename = magenta

[core]
    # display non-ASCII characters (e.g. Polish) instead of quoting them
    quotepath = false
    editor = vim

[diff]
    mnemonicprefix = true

    # detect renamed files and show only actual differences between versions
    renames = copies

[help]
    # correct and run mistyped commands after 1.3 sec delay
    autocorrect = 13

[merge]
    # in case of merge conflict also show how common ancestor looked like
    conflictstyle = diff3

    # Add summaries of merged commits to the merge commit message.
    log = true

[pager]
    # don't wrap lines in output of git blame
    blame = "less -SR"

[push]
    default = simple

[rebase]
    # automatically process "fixup!" commits when rebasing interactively
    autosquash = true

    # stash unstaged changes if rebasing a dirty tree
    autostash = true

[rerere]
    # Reuse recorded resolution of conflicted merges, see 'git help rerere'
    enabled = true

[include]
    # load account-specific settings from a file managed outside dotfiles repo
    path = config.local
